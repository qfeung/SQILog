## 简化版桶排序

### 题目

> 输入n个0~1000之间的整数,将它们从大到小排列.

### Show Code

```
#include <stdio.h>

int main(int argc, const char * argv[]) {

    int book[1001],i,j,t,n;
    
    for (i = 0; i <= 1001; i++) {
        book[i] = 0;
    }
    
    // 输入整数n, 代表需要排序的数字个数
    printf("请输入需要排序的数字个数:\n");
    scanf("%d", &n);
    
    // 循环录入n个整数
    for (i = 0; i < n; i++) {
        printf("请输入第%d/%d个整数:\n", i + 1, n);
        scanf("%d", &t);
        book[t]++;
    }
    
    printf("从小到大排序如下:\n");
    for (i = 0; i <= 1001; i++) {
        if (book[i] != 0) {
            for (j = 0; j < book[i]; j++) {
                printf("-> %d\n", i);
            }
        }
    }
    return 0;
}
```

### Debug area

![控制台打印](https://github.com/qfeung/SQIMaterials/blob/master/Markdown/%E7%AE%80%E5%8C%96%E7%89%88%E6%A1%B6%E6%8E%92%E5%BA%8F001.png?raw=true)

---

### 核心思想

1. book数组起到了"桶"的标记作用, 需要排序的数字 *t* 出现了几次, 那么标号为 *t* 的桶内的数值就是几.(标号为 *t* 的桶 -> book[t]).

### 复杂度

#### 时间复杂度

1. Line 7 -> m次(桶的个数).
2. Line 16 -> n次
3. Line 23 & Line 25 -> m + n 次
4. 所以总的时间复杂度为 `O(m+n+m+n)` = `O(2*(m+n))`. 我们在说时间复杂度的时候可以忽略较小的常数, 最终, 简易桶排序的时间复杂度为`O(m+n)`, 在表示时间复杂度时, 通常用大写字母表示, 所以此时间复杂度应该写为 -> `O(M+N)`.

#### 空间复杂度

1. `O(N)`.

### Others

1. int变量未初始化的默认初始值, 和变量的类型有关.

	* 局部变量: 在未初始化的情况下, 初始值为随机值.C规范对该初值没有做规定, 具体实现由编译器决定. 如VC/VS等编译器, 会将初始值置为0xCCCCCCCC, 而GCC等编译器则是不可预知的随机值.
	* ①静态局部变量(即带有 static 修饰的局部变量), ②全局变量(包含静态全局变量), 即定义在函数外, 不属于任何一个函数的变量. 这两种的默认初始值为0.

2. 数组未初始化

	* 全局和静态数组都按语言规范要求被初始化为0
	* 对于局部数组，初始化元素个数少于数组元素个数时，数组前面的元素值对应初始化值，后面未被初始化的元素自动初始化为0；
	* 但当局部数组定义时，没有用列表对其初始化，那么数组元素的值是不可预料的，在编程的时候要注意这个问题。
